<script>
  // ===================== CONFIG =====================
  const CONFIG = {
    // Innen-Sensor (ESP32 #1)
    INSIDE: {
      CHANNEL_ID: "3043993",                 // <--- ggf. anpassen
      READ_API_KEY: "5QKSO8HZ6BNPFTDE",      // <--- ggf. anpassen
      FIELDS: { tempC: 1, humPct: 2 }        // Feldnummern für Innen
    },
    // Außen-Sensor (ESP32 #2)
    OUTSIDE: {
      CHANNEL_ID: "3043993",                 // <--- ggf. anpassen
      READ_API_KEY: "5QKSO8HZ6BNPFTDE",      // <--- ggf. anpassen
      FIELDS: { tempC: 3, humPct: 4, uvIndex: 5, windKmh: 6 } // <-- Field 6 für Wind
    },
    UV_NIGHT_THRESHOLD: 0.1,
    DECIMALS_TEMP: 1,
    DECIMALS_HUM: 0,
    DECIMALS_WIND: 1,                         // Anzeigepräzision Wind
    WIND_IS_MPS: false,                       // auf true setzen, falls Field 6 in m/s kommt
    POLL_MS: 60000
  };

  // ============== kleiner Cache (für schnelles Paint) ==============
  const CACHE_KEY = 'lastValues_multiChannel_v2'; // neue Version wegen Wind
  const defaultCache = {
    inTemp: null, inHum: null,
    outTemp: null, outHum: null,
    uv: null,
    windKmh: null,
    tsInTemp: null, tsInHum: null, tsOutTemp: null, tsOutHum: null, tsUv: null, tsWind: null
  };
  const lastValues = Object.assign(
    {},
    defaultCache,
    JSON.parse(localStorage.getItem(CACHE_KEY) || JSON.stringify(defaultCache))
  );

  const statusEl = document.getElementById('status');
  function setStatus(msg){ if(statusEl) statusEl.textContent = `Status: ${msg}`; }
  function validNumberLike(v){ if(v===null||v===undefined) return false; if(typeof v==='string' && v.trim()==='') return false; const n=parseFloat(v); return Number.isFinite(n); }
  function num(x){ const v=parseFloat(x); return Number.isFinite(v)? v : NaN; }

  // ---- Helper: pro Feld letzten Wert holen (egal, wann zuletzt gepostet)
  async function fetchFieldLast(channelId, apiKey, fieldNo){
    const url = `https://api.thingspeak.com/channels/${channelId}/fields/${fieldNo}/last.json?api_key=${encodeURIComponent(apiKey)}`;
    const r = await fetch(url, { cache: 'no-store' });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const d = await r.json();
    const value = d[`field${fieldNo}`];
    const ts = d.created_at;
    return { value, ts };
  }

  async function fetchInside(){
    const { CHANNEL_ID, READ_API_KEY, FIELDS } = CONFIG.INSIDE;
    const promises = [];
    if(FIELDS.tempC) promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.tempC).then(r => ({ key:'inTemp', tsKey:'tsInTemp', ...r })).catch(()=>null));
    if(FIELDS.humPct) promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.humPct).then(r => ({ key:'inHum', tsKey:'tsInHum', ...r })).catch(()=>null));
    const results = (await Promise.all(promises)).filter(Boolean);
    return results;
  }

  async function fetchOutside(){
    const { CHANNEL_ID, READ_API_KEY, FIELDS } = CONFIG.OUTSIDE;
    const promises = [];
    if(FIELDS.tempC)   promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.tempC).then(r   => ({ key:'outTemp', tsKey:'tsOutTemp', ...r })).catch(()=>null));
    if(FIELDS.humPct)  promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.humPct).then(r  => ({ key:'outHum',  tsKey:'tsOutHum',  ...r })).catch(()=>null));
    if(FIELDS.uvIndex) promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.uvIndex).then(r => ({ key:'uv',      tsKey:'tsUv',     ...r })).catch(()=>null));
    if(FIELDS.windKmh) promises.push(fetchFieldLast(CHANNEL_ID, READ_API_KEY, FIELDS.windKmh).then(r => ({ key:'windKmh', tsKey:'tsWind',   ...r })).catch(()=>null));
    const results = (await Promise.all(promises)).filter(Boolean);
    return results;
  }

  function applyValuesFromResults(results){
    let newestTs = null;

    for(const r of results){
      if(!r) continue;
      const { key, tsKey, value, ts } = r;
      if(validNumberLike(value)){
        lastValues[key] = value;
        lastValues[tsKey] = ts || lastValues[tsKey];
      }
      if(ts && (!newestTs || new Date(ts) > new Date(newestTs))) newestTs = ts;
    }

    // persist
    localStorage.setItem(CACHE_KEY, JSON.stringify(lastValues));

    // render
    const n_inT   = num(lastValues.inTemp);
    const n_inH   = num(lastValues.inHum);
    const n_outT  = num(lastValues.outTemp);
    const n_outH  = num(lastValues.outHum);
    const n_uv    = num(lastValues.uv);
    let   n_wind  = num(lastValues.windKmh);

    // ggf. m/s -> km/h
    if(Number.isFinite(n_wind) && CONFIG.WIND_IS_MPS){
      n_wind = n_wind * 3.6;
    }

    document.getElementById('tempInValue').textContent  = Number.isFinite(n_inT)  ? `${n_inT.toFixed(CONFIG.DECIMALS_TEMP)} °C` : '—';
    document.getElementById('humInValue').textContent   = Number.isFinite(n_inH)  ? `${n_inH.toFixed(CONFIG.DECIMALS_HUM)} %`  : '—';
    document.getElementById('tempOutValue').textContent = Number.isFinite(n_outT) ? `${n_outT.toFixed(CONFIG.DECIMALS_TEMP)} °C` : '—';
    document.getElementById('humOutValue').textContent  = Number.isFinite(n_outH) ? `${n_outH.toFixed(CONFIG.DECIMALS_HUM)} %`  : '—';
    document.getElementById('uvValue').textContent      = Number.isFinite(n_uv)   ? n_uv.toFixed(1) : '—';

    // Wind-Anzeige
    const windText = document.getElementById('windValue');
    if(windText){
      windText.textContent = Number.isFinite(n_wind)
        ? `Wind: ${n_wind.toFixed(CONFIG.DECIMALS_WIND)} km/h`
        : 'Wind: --';
    }

    // Windrad-Drehgeschwindigkeit dynamisch anpassen (kürzere Dauer = schneller)
    const vanes = document.getElementById('vanes');
    if(vanes){
      let dur = 1.4; // Default
      if(Number.isFinite(n_wind)){
        const w = Math.min(Math.max(n_wind, 0), 120); // clamp 0..120 km/h
        // 0 km/h ~ 6s (sehr langsam) -> 120 km/h ~ 0.6s (sehr schnell)
        dur = Math.max(0.6, 6 - (w * 0.045));
      }
      vanes.style.animationDuration = `${dur}s`;
    }

    // Himmel/Sonne/Mond je nach UV
    const sky  = document.getElementById('sky');
    const sun  = document.getElementById('sunGroup');
    const moon = document.getElementById('moonGroup');
    const isNight = Number.isFinite(n_uv) ? (n_uv <= CONFIG.UV_NIGHT_THRESHOLD) : false;
    if(isNight){
      sky.setAttribute('fill','url(#skyGradNight)');
      if(sun)  sun.setAttribute('opacity','0');
      if(moon) moon.setAttribute('opacity','1');
    } else {
      sky.setAttribute('fill','url(#skyGradDay)');
      if(sun)  sun.setAttribute('opacity','1');
      if(moon) moon.setAttribute('opacity','0');
    }

    // Zeitstempel (neuester der eingegangenen Messwerte)
    const stamp = newestTs
      || lastValues.tsUv
      || lastValues.tsOutTemp
      || lastValues.tsOutHum
      || lastValues.tsInTemp
      || lastValues.tsInHum
      || lastValues.tsWind;
    document.getElementById('timestamp').textContent =
      `Letzte Aktualisierung: ${ stamp ? new Date(stamp).toLocaleString() : '—' }`;
  }

  // Erstmal Cache zeichnen (falls vorhanden)
  applyValuesFromResults([]);

  // Bootstrap & Polling
  (async function bootstrap(){
    try{
      setStatus('Hole letzte Innen-/Außenwerte …');
      const [inRes, outRes] = await Promise.all([fetchInside(), fetchOutside()]);
      applyValuesFromResults([...inRes, ...outRes]);
      setStatus('Live');
    }catch(e){
      console.warn('Initial fetch failed:', e);
      setStatus('Fehler beim Laden – zeige Cache (falls vorhanden)');
    }

    // Poll-Schleife (mit einfachem Backoff bei Fehlern)
    let delay = CONFIG.POLL_MS;
    async function tick(){
      try{
        const [inRes, outRes] = await Promise.all([fetchInside(), fetchOutside()]);
        applyValuesFromResults([...inRes, ...outRes]);
        setStatus('Live');
        delay = CONFIG.POLL_MS;
      }catch(err){
        console.warn('Poll error:', err);
        setStatus('Verbindungsproblem – neuer Versuch');
        delay = Math.min(delay * 2, 300000); // max 5 min
      }finally{
        setTimeout(tick, delay);
      }
    }
    setTimeout(tick, delay);
  })();
</script>
